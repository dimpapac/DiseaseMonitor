Δημήτρης Παπαχρήστου 
ΑΜ: 1115201500124
Κ24: Προγραμματισμός Συστήματος 

Τα αρχεία κώδικα είναι: 
1. diseaseMonitor.c
2. rbt.c
3. list.c
4. heap.c
5. functions.c 

Τα αρχεία επικεφαλίδας είναι:
1. structs.h 
2. rbt.h
3. list.h
4. heap.h
5. functions.h

Makefile: 
Με την εντολή make γίνεται η μεταγλώττιση των αρχείων και με την εντολή make run εκτελείται 
το πρόγραμμα με βάση τα ορίσματα που δίνονται στο makefile (γραμμή 15)
Για διευκόλυνση υπάρχει και η εντολή make val (αντί για make run) και το πρόγραμμα εκτελείται 
με valgrind (valgrind -v --leak-check=full --show-leak-kinds=all)  


structs.h 
περιέχει όλα τα typedef που έγιναν και δίνει μια καλή εικόνα των δομών 

list.c & list.h 
περιέχουν τις συναρτήσεις που υλοποιούν την λίστα των εγγραφών των ασθενών

rbt.c & rbt.h 
περιέχουν τις συναρτήσεις που υλοποιούν το Red-Black-Tree για τα δέντρα των ημερομηνιών 

function.c & functions.h
περιέχουν βοηθητικές συναρτήσεις του προγράμματος και ό,τι έχει σχέση με τα hash tables, buckets 
και heap

diseaseMonitor.c 
η main συνάρτηση

Για το δέντρο χρησιμοποιήθηκε το Red-Black-Tree που υλοποίησα στο προηγούμενο εξάμηνο για 
το μάθημα Λειτουργικά Συστήματα. 
Για τα duplicates του δέντρου ακολουθήθηκε η τρίτη επιλογή που αναφέρεται στο piazza δηλαδή:
Μια εγγραφή του binary tree δείχνει στον 1ο ασθενή της λίστας με την συγκεκριμένη ημερομηνία 
και μέσω αυτού βρισκονται όλοι οι ασθενείς με την ίδια ημερομηνία εισαγωγής 
(Διατρέχουμε την λίστα μέχρι να βρούμε διαφορετική ημερομηνία).

Για το την υλοποίηση του heap χωρίς πίνακα αξιοποιήθηκε κώδικας από τον εξής λογαριασμό στο
Github https://github.com/hariuserx/MinHeap/blob/master/src/MinHeapWithoutArrays.java
ο οποίος κατανοήθηκε πλήρως και επεξεργάστηκε για να επιλύει τα ζητούμενα της εργασίας.
Για τις εντολές topk η λογική που ακολουθήθηκε είναι η εξής: 
Αρχικά βρίσκουμε το δυαδικό δέντρο για το country που μας δίνεται (στην περίπτωση της πρώτης 
topk εντολής) από τα buckets του countryHashTable. Στην συνέχεια, δημιουργείται μια βοηθητική 
λίστα με κόμβους που περιέχουν τους κόμβους που θα δώσουμε στο heap. Αφού ενημερωθεί η λίστα με 
ένα πέρασμα του δυαδικού δέντρου που πήραμε αρχικά τότε δίνουμε τους κόμβους στο heap και 
κάνουμε διαγραφή της ρίζας (μέγιστη τιμή) k φορές (όπου k η είσοδος από τον χρήστη). 




